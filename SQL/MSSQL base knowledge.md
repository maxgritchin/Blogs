# MS SQL SERVER: Основные понятия простыми словами

Что следует знать программисту про базы данных? Собрал для вас основные понятия, без которых не справиться с MS SQL Server.
Рассмотрим основные понятия достаточные для того, чтобы приступить к изучению внутренней работы MS SQL SERVER и писать эффективные запросы.

## Индексы

Ключ к эффективному использованию MS SQL Server и оптимизации баз данных — это индексы, древовидные структуры хранения данных. Благодаря их использованию вы сможете серьезно повысить производительность обработки запроса к MS SQL серверу. Как?

Самый главный функционал индекса — уменьшение времени на поиск данных во всей системе. Принцип работы индекса такой же, как принцип работы раздела содержание книги: он позволяет обращаться к конкретным данным через поиск по индексу - O (log n) - что сокращает время на “пролистывание” всей книги, т.е. базы данных.

К сожалению, у работы с индексами есть свой минус - это увеличение времени на запись данных в систему. При этом их использование требует дополнительно выделять память в базе данных, ведь чтобы добавить запись в индекс, системе необходимо его перестроить.

![Index Performance](img/idx_perf.png?raw=true "Index performance")

Чтобы избежать малоэффективного поиска значения, необходимо правильно подобрать параметры, подобрать параметры индекса, и задействоать в построении только тот набор колонок, который необходим для выборки. Причем порядок определения колонок важен и он будет влиять на план выполнени запроса. Подобранные параметры должны быть проиндексированы, а "физические данные" базы хранятся отдельно от структуры индекса.

Индексы делятся на два типа — кластерные и некластерные.

Каждый раз когда вам требуется провести поиск по таблице, сервер будет сканировать индекс в поисках искомых значений. Вы можете задать индексы, поддерживающие ограничения: unique constraint, unique index и primary key. Если таблице не был присвоен кластерный индекс, то он появится после формирования primary key. То есть primary key использует кластерный индекс.

Что же касается некластерных индексов, их может быть больше одного . Чем меньше индексов тем быстрее запись. Так что не нужно создавать индексы для каждой колонки. Индексы позволяют логически сортировать данные, которые ссылаются на значения на физическом носителе ( или на элемент кластерного индекса). Каждый некластерный индекс будет содержать значения ключей, а также указатели на строки в таблице с значениями.  

## B-Tree

B-Tree - это структура данных, которая является основой для построения индексов и поиска значений по ним.  Корневой узел — это точка входа. У него два дочерних узла, у которых могут быть свои дочерние узлы и так далее. Каждый из них хранит ссылки на данные из строк таблиц. Если это кластерный индекс, то узел хранит не ссылки, а непосредственно данные. 

B-дерево позволяет производить бинарный поиск данных (эффективный поиск по отсортированным данным).

![B-tree](img/b_tree.png?raw=true "B-tree")

Если n — это количество данных, то понадобится n+1 нод для их хранения. Существует текущая нода, которая хранит данные, а также левая и правая. Ключ левой ноды будет меньше, чем ключ текущей. С правой — наоборот. 

В базах данных используются B+ деревья, которые позволяют провести выборку по всем узлам, а также выбрать все данные на одном уровне (линейный поиск). Это подойдет для тех случаев когда нужно вернуть данные из заданного интервала значений. 

![B-tree+](img/b_tree_plus.png?raw=true "B Tree Plus")

Рост числа записей на одном уровне экспоненциальный, например, если требуется найти одну запись среди двух миллионов, потребуется всего лишь 9 итераций.

![Exponentional Grow](img/exp.png?raw=true "Exponentional Grow")

## Транзакции

Транзакция — это несколько операций над базой данных, объединенных в одну. 
Транзакция поддерживает свойства ACID:

 - A - Atomicity:
 Атомарность позволяет решать проблему потери данных путем запрещения частичной фиксации изменений. Если транзакция правильно прописана, то все указанные изменения будут полностью выполнены. Если же нет, то никаких изменений не произойдет;
 - C - Consistency:
 Согласованность гарантирует переход состояния базы из одного валидного состояния в другое без потери изменений;
 - I - Isolation:
 Изоляция обеспечивает возможность работать в многопоточном режиме так, чтобы разные потоки не “перетирали” данные друг друга;
 - D - Durability:
 Отказоустойчивость гарантирует сохранность данных  — если транзакция прошла успешно, то данные не потеряются даже если произойдет отключение электричества.

 Если транзакция не прописана четко, то каждое SQL выражение выполняется в транзакции неявно. Для MS SQL транзакция по умолчанию обычно Read Committed (если не настроено иное). В базах данных существует несколько поддерживаемых уровней изоляции. Каждый уровень включает предыдущий.

 ### Проблемы, которые решают транзакции 

 Доступ к к одним и тем же данным в разных транзакциях может при вести к ряду проблем:

- Грязное чтение - транзакция читает данные из другой транзакции, которые еще не были зафиксированы;
- Потерянное обновление при одновременном изменении одних и тех же данных разными транзакциями (одно изменение не выполнено);
- Неповторяющееся чтение, то есть такая ситуация, когда при повторном чтении  одних и тех же данных внутри транзакции имеем измененный набор значений;
- Фантомные чтения: при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк (отличается от неповторяющихся чтений тем, что в данном случае появляются новые фантомные данные, а в предыдущем случае они изменяются);

### Уровни изоляций

Уровни изоляции транзакций позволяют решать указанные выше пробелмы

#### Read Uncommitted 

При одновременном изменении данных несколькими транзакциями будут зафиксированы изменения только одной из них. Кроме того могут быть прочитаны еще не зафиксированные данные. Первый уровень изоляции который не блокирует потоки для записи или чтения. При этом не блокируются фантомные, неповторяющиеся и грязные чтения.

#### Read Committed

Позволяет избавится от грязных чтений. Если же другая транзакция зафиксирует данные, то при повторном чтении мы получим иной набор данных. В некоторых случаях такая ситуация неприемлема для логики приложения.

#### Repeatable Read 

Предотвращает проблему разного набора данных при повторном чтении. Для этого транзакция предотвращает изменение прочитанных данных.

#### Serializable

Только этот уровень позволяет предотвратить фантомное чтение. В данном случае транзакция обрабатывает только данные, существовавшие до ее начала. 


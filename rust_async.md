# Asynс Rust: Что такое Runtime и как работает tokio

Без установки дополнительных пакетов, Rust не поддерживает Features и Streams. Что делает невозможным работу с асинхронностью. 

Futures — это значения, получаемые асинхронными вычислениями. Некоторые другие языки программирования (например, JavaScript) называют такие значения Promise.
Streams — это ряд значений, полученных таким же способом.

В Rust контекст выполнения называется Runtime (среда выполнения), без которого невозможно запустить Async программу.

Самые популярные среды выполнения для асинхронных вычислений 

|Среда выполнения|Описание|
|--|--|
|[tokio](https://crates.io/crates/tokio)|Событийно-ориентированная I\O платформа для написания асинхронных I\O приложений.|
|[async-std](https://crates.io/crates/async-std)|Асинхронная версия стандартной библиотеки Rust|
|[smol](https://crates.io/crates/smol)|Небольшая, но быстрая среда выполнения|

К сожалению, тут могут возникнуть проблемы. И самая главная из них — это совместимость. Между этими средами выполнения невозможно переключаться просто изменив несколько строчек кода. Приходится выбрать что-то одно и использовать в своем проекте. 

## Tokio

Tokio — это асинхронная среда выполнения Rust с огромной поддержкой со стороны коммьюнити и многими спонсорами, как, например, Discord, Fly.io и Embark. На мой взгляд эта среда выполнения выбирается по умолчанию.  

Команда Tokio создала крайне удобную среду выполнения и полезные инструменты для создания сетевых сервисов, включая НТТР, gRPC, трассировку и так далее.

Если вы не являетесь embedded-разработчиком, то Tokio — это наилучший вариант. 

В основе всех асинхронных сред выполнения (Rust, Node.js и любом другом языке) лежат циклы событий, также известные как процессоры.

![Rust processor](img/rust_processor.png?raw=true "Rust processor")

Для повышения производительности часто используется несколько процессоров на программу, по одному на каждое CPU ядро.

Каждый цикл событий имеет свою собственную очередь задач, ожидающих завершения. Tokio — это решение, которое “отнимает работу”. Каждый отдельный цикл может “украсть” задачу в очереди другого процессора, если его собственная очередь пуста (т.е. ему нечего делать и он “сидит без дела”).

### Функция Spawn

Если вам понадобится отправить задачу в среду выполнения для ее запуска, необходимо вызвать функцию `tokio::spawn`.
Например:

```rust
async fn process(socket: TcpStream) {
    // ...
}

#[tokio::main]
async fn main() -> io::Result<()> {
    let mut listener = TcpListener::bind("127.0.0.1:8080").await?;

    loop {
        let (socket, _) = listener.accept().await?;

        tokio::spawn(async move {
            // Process each socket concurrently.
            process(socket).await
        });
    }
}
```

Этот фрагмент кода запустит одну задачу, которая будет поставлена в очередь на один из процессоров. Rаждый из них имеет свой собственный поток OS. Таким образом, запуская задачу, мы используем все ресурсы нашего устройства без необходимости управлять потоками самостоятельно. Без этого все операции будут выполняться на одном процессоре и, следовательно, в одном потоке.

Для сравнения, в Go используется ключевое слово go для запуска задачи (так называемой goroutine):

```go
go doSomething()
```

Самое важное правило работы с async-await - не блокировать цикл событий.

Что это значит? Нельзя вызывать функции, которые могут работать более 10 до 100 микросекунд. Вместо этого, необходимо использовать метод `spawn_blocking`.

Итак, как же проводить сложные операции, такие как шифрование, кодирование изображений или хеширование файлов?

Tokio предоставляет доступ к функции `tokio:::task::spawn_blocking`, которая позволяет блокировать поток в ожидании завершения операции. В данном случае блокировка не является бесконечной фоновой работой. Для такого рода задач больше подходит Rust Thread.

Пример использования такой блокировки:

```rust
let is_expected = tokio:::task::spawn_blocking(move || verify_code(&code, &code_hash)).await?;
```

Функция `verify_code`, в примере выше, быстро завершит цикл событий. Если же вызвать spawn_blocking, то операция отправляется в потоковой пул Tokio.

![Rust runtime](img/rust_tokio_runtime.png?raw=true "Rust runtime")

Tokio поддерживает два пула потоков.

Один — фиксированного размера для процессоров, которые выполняют асинхронные задачи. Асинхронные задачи могут быть отправлены в этот пул с помощью `tokio::spawn`. Второй пул, ограниченный по размеру, по умолчанию увеличен до 512 потоков. Этот пул потоков может быть уменьшен в зависимости от количества запущенных задач. Чтобы отправить задачу в этот пул, необходимо использовать `tokio::task::spawn_blocking`. Подробнее о том, как правильно настроить пулы, вы можете прочитать в [документации Tokio](https://docs.rs/tokio/latest/tokio/runtime/struct.Builder.html#method.max_blocking_threads).